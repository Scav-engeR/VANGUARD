#!/usr/bin/env python3
"""
Vulnerability analyzer module for detecting and classifying security vulnerabilities.
"""

import logging
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

logger = logging.getLogger("deep_analytics.analyzer")

class VulnerabilityAnalyzer:
    """Analyzes scan data to identify and classify security vulnerabilities."""

    def __init__(self, cve_matcher, evidence_collector, verify_vulnerabilities=True):
        """
        Initialize the vulnerability analyzer.

        Args:
            cve_matcher: CVEMatcher instance for finding related CVEs
            evidence_collector: EvidenceCollector instance for gathering evidence
            verify_vulnerabilities: Whether to actively verify vulnerabilities
        """
        self.cve_matcher = cve_matcher
        self.evidence_collector = evidence_collector
        self.verify_vulnerabilities = verify_vulnerabilities

        # Define vulnerability types and their analysis methods
        self.vulnerability_types = {
            'SQLi': self.analyze_sqli,
            'XSS': self.analyze_xss,
            'RCE': self.analyze_rce,
            'LFI': self.analyze_lfi
        }

        # Define test payloads for verification
        self.test_payloads = {
            'SQLi': [
                "id=1' OR '1'='1",
                "id=1 OR 1=1",
                "id=1; DROP TABLE users--",
                "id=1 UNION SELECT username,password FROM users--"
            ],
            'XSS': [
                "name=<script>alert('XSS')</script>",
                "name=<img src='x' onerror='alert(1)'>",
                "name=<svg onload='alert(1)'>",
                "name=<iframe src='javascript:alert(1)'>"
            ],
            'RCE': [
                "cmd=ls",
                "cmd=cat /etc/passwd",
                "cmd=whoami",
                "cmd=id"
            ],
            'LFI': [
                "file=../../../etc/passwd",
                "file=../../../windows/win.ini",
                "file=../../../proc/self/environ",
                "file=/proc/self/environ"
            ]
        }

    def analyze(self, scan_data):
        """
        Analyze scan data to identify vulnerabilities.

        Args:
            scan_data: List of dictionaries containing scan results

        Returns:
            List of dictionaries containing vulnerability findings
        """
        findings = []

        # Process each target in the scan data
        with ThreadPoolExecutor(max_workers=10) as executor:
            # Submit analysis tasks
            future_to_target = {
                executor.submit(self.analyze_target, target): target
                for target in scan_data
            }

            # Process results as they complete
            for future in as_completed(future_to_target):
                target = future_to_target[future]
                try:
                    result = future.result()
                    if result:
                        findings.append(result)
                except Exception as e:
                    logger.error(f"Error analyzing target {target.get('URL', 'unknown')}: {str(e)}")

        return findings

    def analyze_target(self, target):
        """
        Analyze a single target for vulnerabilities.

        Args:
            target: Dictionary containing target information

        Returns:
            Dictionary containing vulnerability findings, or None if no vulnerabilities
        """
        url = target.get('URL')
        if not url:
            return None

        logger.info(f"Analyzing target: {url}")

        # Check each vulnerability type
        vulnerabilities = []
        for vuln_type, analysis_method in self.vulnerability_types.items():
            # Skip if scan data indicates no vulnerability
            if vuln_type in target and not target[vuln_type]:
                continue

            # Analyze this vulnerability type
            vuln = analysis_method(url, target)
            if vuln:
                vulnerabilities.append(vuln)

        # Return findings if vulnerabilities were found
        if vulnerabilities:
            return {
                'url': url,
                'status_code': target.get('Status'),
                'server': target.get('Server'),
                'vulnerabilities': vulnerabilities,
                'evidence': self.evidence_collector.collect_evidence(url, vulnerabilities)
            }

        return None

    def analyze_sqli(self, url, target_data):
        """
        Analyze target for SQL Injection vulnerabilities.

        Args:
            url: Target URL
            target_data: Dictionary containing target information

        Returns:
            Dictionary containing vulnerability details, or None if not vulnerable
        """
        # Skip verification if not requested
        if self.verify_vulnerabilities:
            verified = self._verify_vulnerability(url, 'SQLi')
            if not verified:
                return None

        # Extract injection points
        injection_points = self._find_injection_points(url)

        # Determine database type based on server or error messages
        db_type = self._infer_database_type(target_data.get('Server', ''))

        # Calculate severity
        severity = self._calculate_severity('SQLi', url, injection_points, db_type)

        # Find related CVEs
        cves = self.cve_matcher.find_cves('SQLi', url, target_data.get('Server', ''))

        return {
            'type': 'SQL Injection',
            'severity': severity,
            'description': 'SQL injection vulnerability allows an attacker to modify database queries',
            'technical_details': {
                'vulnerable_parameter': injection_points[0] if injection_points else 'Unknown',
                'injection_point': 'GET parameter' if '?' in url else 'POST parameter',
                'database_type': db_type,
                'exploitation_potential': 'Full database access possible',
                'affected_functionality': 'User authentication bypass, data exfiltration'
            },
            'proof_of_concept': self._generate_poc('SQLi', url, injection_points),
            'cwe': 'CWE-89',
            'potential_cves': cves,
            'remediation': self._generate_remediation('SQLi')
        }

    def analyze_xss(self, url, target_data):
        """Analyze target for Cross-Site Scripting vulnerabilities."""
        # Implementation similar to analyze_sqli
        if self.verify_vulnerabilities:
            verified = self._verify_vulnerability(url, 'XSS')
            if not verified:
                return None

        injection_points = self._find_injection_points(url)
        severity = self._calculate_severity('XSS', url, injection_points)
        cves = self.cve_matcher.find_cves('XSS', url, target_data.get('Server', ''))

        return {
            'type': 'Cross-Site Scripting (XSS)',
            'severity': severity,
            'description': 'XSS vulnerability allows attackers to inject client-side scripts into web pages',
            'technical_details': {
                'vulnerable_parameter': injection_points[0] if injection_points else 'Unknown',
                'injection_point': 'GET parameter' if '?' in url else 'POST parameter',
                'xss_type': 'Reflected',  # Could be Stored or DOM-based in a more sophisticated analysis
                'exploitation_potential': 'Session hijacking, phishing attacks',
                'affected_functionality': 'Client-side application security'
            },
            'proof_of_concept': self._generate_poc('XSS', url, injection_points),
            'cwe': 'CWE-79',
            'potential_cves': cves,
            'remediation': self._generate_remediation('XSS')
        }

    def analyze_rce(self, url, target_data):
        """Analyze target for Remote Code Execution vulnerabilities."""
        # Implementation similar to analyze_sqli
        if self.verify_vulnerabilities:
            verified = self._verify_vulnerability(url, 'RCE')
            if not verified:
                return None

        injection_points = self._find_injection_points(url)
        severity = self._calculate_severity('RCE', url, injection_points)
        cves = self.cve_matcher.find_cves('RCE', url, target_data.get('Server', ''))

        return {
            'type': 'Remote Code Execution (RCE)',
            'severity': severity,
            'description': 'RCE vulnerability allows execution of arbitrary code on the target system',
            'technical_details': {
                'vulnerable_parameter': injection_points[0] if injection_points else 'Unknown',
                'injection_point': 'GET parameter' if '?' in url else 'POST parameter',
                'server_type': target_data.get('Server', 'Unknown'),
                'exploitation_potential': 'Full system compromise',
                'affected_functionality': 'Server-side application security'
            },
            'proof_of_concept': self._generate_poc('RCE', url, injection_points),
            'cwe': 'CWE-78',
            'potential_cves': cves,
            'remediation': self._generate_remediation('RCE')
        }

    def analyze_lfi(self, url, target_data):
        """Analyze target for Local File Inclusion vulnerabilities."""
        # Implementation similar to analyze_sqli
        if self.verify_vulnerabilities:
            verified = self._verify_vulnerability(url, 'LFI')
            if not verified:
                return None

        injection_points = self._find_injection_points(url)
        severity = self._calculate_severity('LFI', url, injection_points)
        cves = self.cve_matcher.find_cves('LFI', url, target_data.get('Server', ''))

        return {
            'type': 'Local File Inclusion (LFI)',
            'severity': severity,
            'description': 'LFI vulnerability allows inclusion of local files on the server',
            'technical_details': {
                'vulnerable_parameter': injection_points[0] if injection_points else 'Unknown',
                'injection_point': 'GET parameter' if '?' in url else 'POST parameter',
                'server_type': target_data.get('Server', 'Unknown'),
                'exploitation_potential': 'Sensitive file disclosure, possible RCE via log poisoning',
                'affected_functionality': 'File inclusion functionality'
            },
            'proof_of_concept': self._generate_poc('LFI', url, injection_points),
            'cwe': 'CWE-98',
            'potential_cves': cves,
            'remediation': self._generate_remediation('LFI')
        }

    def _verify_vulnerability(self, url, vuln_type):
        """
        Verify if a target is actually vulnerable by testing with payloads.

        Args:
            url: Target URL
            vuln_type: Type of vulnerability to verify

        Returns:
            Boolean indicating if vulnerability was verified
        """
        logger.info(f"Verifying {vuln_type} vulnerability for {url}")

        # Use a safer approach for verification that won't actually exploit the vulnerability
        # This is for demonstration and would need more sophisticated checks in a real tool

        try:
            # Extract base URL and parameters
            parsed_url = urlparse(url)
            base_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, '', '', ''))

            # Get original response for comparison
            original_response = requests.get(url, timeout=5)

            # Try a few test payloads
            for payload in self.test_payloads.get(vuln_type, [])[:2]:  # Limit to first 2 payloads
                # Create test URL with the payload
                param_name = payload.split('=')[0]
                param_value = payload.split('=')[1]

                # Modify existing parameters or add new one
                params = parse_qs(parsed_url.query)
                if param_name in params:
                    params[param_name] = [param_value]
                else:
                    params[param_name] = [param_value]

                # Construct test URL
                test_query = urlencode(params, doseq=True)
                test_url = urlunparse((
                    parsed_url.scheme, parsed_url.netloc, parsed_url.path,
                    parsed_url.params, test_query, parsed_url.fragment
                ))

                # Send test request
                test_response = requests.get(test_url, timeout=5)

                # Check for signs of vulnerability
                # This is a simplified check and would need more sophisticated analysis in practice
                if self._detect_vulnerability_signs(vuln_type, original_response, test_response):
                    logger.info(f"Verified {vuln_type} vulnerability in {url}")
                    return True

            logger.info(f"Could not verify {vuln_type} vulnerability in {url}")
            return False

        except Exception as e:
            logger.warning(f"Error verifying {vuln_type} vulnerability for {url}: {str(e)}")
            # If verification fails, default to trusting the scan results
            return True

    def _detect_vulnerability_signs(self, vuln_type, original_response, test_response):
        """
        Detect signs of vulnerability by comparing original and test responses.

        Args:
            vuln_type: Type of vulnerability being checked
            original_response: Response from the original URL
            test_response: Response from the URL with test payload

        Returns:
            Boolean indicating if vulnerability signs were detected
        """
        # Different checks for different vulnerability types
        if vuln_type == 'SQLi':
            # Look for SQL error messages
            sql_errors = [
                'sql syntax', 'mysql_fetch', 'sqlite_error', 'ORA-', 'SQL Server',
                'PostgreSQL', 'mysqli_', 'ODBC', 'syntax error'
            ]
            for error in sql_errors:
                if error.lower() in test_response.text.lower() and error.lower() not in original_response.text.lower():
                    return True

            # Check for significant response differences
            if len(test_response.text) > len(original_response.text) * 1.5:
                return True

        elif vuln_type == 'XSS':
            # Look for our injected script in the response
            if '<script>alert' in test_response.text or 'onerror=' in test_response.text:
                return True

        elif vuln_type == 'RCE':
            # Look for command output patterns
            if 'uid=' in test_response.text or 'gid=' in test_response.text:
                return True
            if 'Windows' in test_response.text and 'Directory of' in test_response.text:
                return True

        elif vuln_type == 'LFI':
            # Look for file content patterns
            if 'root:x:0:0' in test_response.text or '[fonts]' in test_response.text:
                return True

        return False

    def _find_injection_points(self, url):
        """
        Find potential injection points in a URL.

        Args:
            url: Target URL

        Returns:
            List of parameter names that could be injection points
        """
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)

        # Common injectable parameter names
        common_injectable = ['id', 'page', 'file', 'cmd', 'query', 'search', 'name', 'user']

        # First prioritize common injectable parameters
        injection_points = [param for param in params if param.lower() in common_injectable]

        # Then add all other parameters
        injection_points.extend([param for param in params if param.lower() not in common_injectable])

        return injection_points

    def _infer_database_type(self, server_info):
        """
        Infer database type from server information.

        Args:
            server_info: Server information string

        Returns:
            Inferred database type
        """
        server_info = server_info.lower()

        if 'mysql' in server_info or 'mariadb' in server_info:
            return 'MySQL/MariaDB'
        elif 'postgresql' in server_info or 'postgres' in server_info:
            return 'PostgreSQL'
        elif 'mssql' in server_info or 'sqlserver' in server_info:
            return 'Microsoft SQL Server'
        elif 'oracle' in server_info:
            return 'Oracle'
        elif 'sqlite' in server_info:
            return 'SQLite'
        elif 'php' in server_info:
            return 'MySQL (inferred from PHP)'
        elif 'asp' in server_info or 'iis' in server_info:
            return 'Microsoft SQL Server (inferred from ASP/IIS)'
        elif 'jsp' in server_info or 'tomcat' in server_info:
            return 'Oracle/MySQL (inferred from JSP/Tomcat)'
        else:
            return 'Unknown (possibly MySQL)'

    def _calculate_severity(self, vuln_type, url, injection_points, db_type=None):
        """
        Calculate severity rating for a vulnerability.

        Args:
            vuln_type: Type of vulnerability
            url: Target URL
            injection_points: List of potential injection points
            db_type: Database type (for SQLi vulnerabilities)

        Returns:
            Dictionary containing severity information
        """
        # Base CVSS scores for different vulnerability types
        base_scores = {
            'SQLi': 8.5,
            'RCE': 9.8,
            'XSS': 6.1,
            'LFI': 7.5
        }

        # Adjust score based on various factors
        score = base_scores.get(vuln_type, 5.0)

        # Adjust for authentication
        if 'login' in url or 'admin' in url:
            score += 0.5

        # Adjust for database type (for SQLi)
        if vuln_type == 'SQLi' and db_type:
            if 'oracle' in db_type.lower() or 'sql server' in db_type.lower():
                score += 0.3

        # Cap at 10.0
        score = min(score, 10.0)

        # Determine rating based on score
        if score >= 9.0:
            rating = 'Critical'
        elif score >= 7.0:
            rating = 'High'
        elif score >= 4.0:
            rating = 'Medium'
        else:
            rating = 'Low'

        # Generate CVSS vector
        if vuln_type == 'SQLi':
            vector = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L'
        elif vuln_type == 'RCE':
            vector = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
        elif vuln_type == 'XSS':
            vector = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N'
        elif vuln_type == 'LFI':
            vector = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N'
        else:
            vector = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L'

        return {
            'rating': rating,
            'cvss_score': score,
            'cvss_vector': vector
        }

    def _generate_poc(self, vuln_type, url, injection_points):
        """
        Generate proof of concept for a vulnerability.

        Args:
            vuln_type: Type of vulnerability
            url: Target URL
            injection_points: List of potential injection points

        Returns:
            String containing proof of concept code or payload
        """
        # Extract base URL and parameters
        parsed_url = urlparse(url)
        base_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, '', '', ''))

        # Select appropriate payload based on vulnerability type
        if vuln_type == 'SQLi':
            payload = "id=1' OR '1'='1"
        elif vuln_type == 'XSS':
            payload = "name=<script>alert('XSS')</script>"
        elif vuln_type == 'RCE':
            payload = "cmd=cat+/etc/passwd"
        elif vuln_type == 'LFI':
            payload = "file=../../../etc/passwd"
        else:
            payload = "param=test"

        # If we have specific injection points, use the first one
        if injection_points:
            param_name = injection_points[0]
            param_value = payload.split('=')[1]
            payload = f"{param_name}={param_value}"

        # Generate the PoC
        return f"""
# Proof of Concept for {vuln_type} vulnerability
# Target: {url}

import requests

# Target information
url = "{base_url}"

# Payload that triggers the vulnerability
payload = "{payload}"

# Send the request
response = requests.get(f"{{url}}?{{payload}}")

# Check if the exploitation was successful
print(f"Status Code: {{response.status_code}}")
print("Response Preview:")
print(response.text[:500])  # First 500 characters
"""

    def _generate_remediation(self, vuln_type):
        """
        Generate remediation recommendations for a vulnerability.

        Args:
            vuln_type: Type of vulnerability

        Returns:
            List of remediation steps
        """
        remediation_templates = {
            'SQLi': [
                "Use prepared statements or parameterized queries",
                "Apply input validation for all user-supplied data",
                "Implement proper output encoding",
                "Apply the principle of least privilege to database accounts",
                "Consider using an ORM framework that handles SQL escaping",
                "Implement a Web Application Firewall (WAF) as an additional defense layer"
            ],
            'XSS': [
                "Implement context-appropriate output encoding",
                "Use Content Security Policy (CSP) headers",
                "Validate and sanitize all user inputs",
                "Use modern frameworks that automatically escape output",
                "Apply the HttpOnly flag to sensitive cookies",
                "Consider using a Web Application Firewall (WAF)"
            ],
            'RCE': [
                "Avoid using functions that execute system commands",
                "Implement strict input validation and sanitization",
                "Apply the principle of least privilege",
                "Use allowlists for permitted commands instead of blocklists",
                "Update and patch server software regularly",
                "Consider using application containerization"
            ],
            'LFI': [
                "Validate and sanitize file paths",
                "Use path mapping instead of direct file inclusion",
                "Implement proper access controls",
                "Avoid using user input directly in file operations",
                "Consider using a Web Application Firewall (WAF)",
                "Keep server software updated with security patches"
            ]
        }

        return remediation_templates.get(vuln_type, [
            "Implement input validation",
            "Apply output encoding",
            "Keep software updated",
            "Use the principle of least privilege"
        ])